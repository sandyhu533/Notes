# 推/拉模型

#### 1.1 推模型和拉模型 <a id="1.1-%E6%8E%A8%E6%A8%A1%E5%9E%8B%E5%92%8C%E6%8B%89%E6%A8%A1%E5%9E%8B"></a>

在观察者模式中，又分为推模型和拉模型两种方式。　

**推模型**：主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。

**拉模型**：主题对象在通知观察者的时候，只传递少量信息。如果观察者需要更具体的信息，由观察者主动到主题对象中获取，相当于是观察者从主题对象中拉数据。

具体两个模型详细剖析如下：

**1.1.1 推模型：**

**特点：**

* 基于客户器/服务器机制、由服务器主动将信息送到客户器的技术；
* “推”的方式是指，Subject维护一份观察者的列表，每当有更新发生，Subject会把更新消息主动推送到各个Observer去。
* 服务器把信息送给客户器之前，并没有明显的客户请求，push事务由服务器发起；
* 主题对象向观察者推送主题的详细信息，不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据。
* 推模型是假定主题对象知道观察者需要的数据；

**优点：**

* push模式可以让信息主动、快速地寻找用户/客户器，信息的主动性和实时性比较好。
* **高效。如果没有更新发生，不会有任何更新消息推送的动作，即每次消息推送都发生在确确实实的更新事件之后，都是有意义的。**
* **实时。事件发生后的第一时间即可触发通知操作。**
* 可以由Subject确立通知的时间，可以避开一些繁忙时间。
* 可以表达出不同事件发生的先后顺序

**缺点：**

* 精确性较差，可能推送的信息并不一定满足客户的需求。推送模式不能保证能把信息送到客户器；
* 因为推模式采用了广播机制，如果客户器正好联网并且和服务器在同一个频道上，推送模式才是有效的；
* push模式无法跟踪状态，采用了开环控制模式，没有用户反馈信息；
* 不管观察者是否需要，推送的信息通常是主题对象的全部或部分数据；

**1.1.2 拉模型**

**特点：**

* 是由客户器主动发起的事务。服务器把自己所拥有的信息放在指定地址（如IP、port），客户器向指定地址发送请求，把自己需要的资源“拉”回来；
* “拉”的方式是指，各个Observer维护各自所关心的Subject列表，自行决定在合适的时间去Subject获取相应的更新数据；
* 拉模型是主题对象不知道观察者具体需要什么数据，没有办法的情况下，干脆把自身传递给观察者，让观察者自己去按需要取值；

**优点：**

* 不仅可以准确获取自己需要的资源，还可以及时把客户端的状态反馈给服务器；
* **如果观察者众多，Subject来维护订阅者的列表可能困难或者臃肿，这样可以把订阅关系解脱到Observer去完成；**
* Observer可以不理会它不关心的变更事件，只需要去获取自己感兴趣的事件即可；
* Observer可以自行决定获取更新事件的时间；
* 拉的形式可以让Subject更好地控制各个Observer每次查询更新的访问权限；

**缺点：**

* **最大的缺点就是不及时；**

{% embed url="https://www.cnblogs.com/rossiXYZ/p/14123647.html" %}

{% embed url="https://www.jianshu.com/p/fcf61ea79f8b" %}

\*\*\*\*

